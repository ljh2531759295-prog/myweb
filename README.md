# ğŸµ ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨

> åŸºäº Vue 3 + Electron + Node.js çš„å…¨æ ˆéŸ³ä¹æ’­æ”¾å™¨åº”ç”¨

[![Vue](https://img.shields.io/badge/Vue-3.x-4FC08D?style=flat-square&logo=vue.js)](https://vuejs.org/)
[![Electron](https://img.shields.io/badge/Electron-Latest-47848F?style=flat-square&logo=electron)](https://electronjs.org/)
[![Node.js](https://img.shields.io/badge/Node.js-18+-339933?style=flat-square&logo=node.js)](https://nodejs.org/)
[![License](https://img.shields.io/badge/License-MIT-blue?style=flat-square)](LICENSE)

## ğŸ“– é¡¹ç›®æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„æ¡Œé¢éŸ³ä¹æ’­æ”¾å™¨ï¼Œé›†æˆäº†åœ¨çº¿éŸ³ä¹æœç´¢ã€ä¸‹è½½ã€æœ¬åœ°æ’­æ”¾ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚é¡¹ç›®é‡‡ç”¨ç°ä»£åŒ–çš„å‰åç«¯åˆ†ç¦»æ¶æ„ï¼Œé€šè¿‡é€†å‘å·¥ç¨‹ç½‘æ˜“äº‘éŸ³ä¹APIå®ç°äº†å®Œæ•´çš„éŸ³ä¹æœåŠ¡åŠŸèƒ½ã€‚

### ğŸ¯ æ ¸å¿ƒç‰¹æ€§

- **ğŸ” æ™ºèƒ½æœç´¢** - å®æ—¶æœç´¢ç½‘æ˜“äº‘éŸ³ä¹åº“ï¼Œæ”¯æŒæ­Œæ›²ã€æ­Œæ‰‹ã€ä¸“è¾‘å¤šç»´åº¦æ£€ç´¢
- **â¬‡ï¸ é«˜è´¨é‡ä¸‹è½½** - æ”¯æŒå¤šç§éŸ³è´¨ä¸‹è½½ï¼ˆæ ‡å‡†/é«˜å“/æ— æŸ/Hi-Resï¼‰ï¼ŒVIPæ­Œæ›²è§£é”
- **ğŸµ ä¸“ä¸šæ’­æ”¾å™¨** - è‡ªç ”éŸ³é¢‘å¼•æ“ï¼Œæ”¯æŒå¤šæ ¼å¼è§£ç ï¼Œæ— æŸéŸ³è´¨æ’­æ”¾
- **ğŸ¼ æ­Œè¯åŒæ­¥** - LRCæ ¼å¼æ­Œè¯è§£æä¸æ¯«ç§’çº§å®æ—¶åŒæ­¥æ˜¾ç¤ºï¼Œæ”¯æŒæ­Œè¯ç¼–è¾‘
- **ğŸ›ï¸ æ’­æ”¾æ§åˆ¶** - å®Œæ•´çš„æ’­æ”¾æ§åˆ¶ç³»ç»Ÿï¼Œæ”¯æŒéšæœºã€å¾ªç¯ã€é¡ºåºæ’­æ”¾æ¨¡å¼
- **ğŸ“± ç°ä»£UI** - å“åº”å¼è®¾è®¡ï¼ŒCDæ—‹è½¬åŠ¨ç”»ï¼Œè¿›åº¦æ¡æ‹–æ‹½ï¼Œæ—¥å¤œä¸»é¢˜åˆ‡æ¢
- **ğŸ“‚ æœ¬åœ°ç®¡ç†** - éŸ³ä¹åº“ç®¡ç†ï¼Œæ’­æ”¾åˆ—è¡¨åˆ›å»ºï¼Œæ”¶è—åŠŸèƒ½ï¼Œæ™ºèƒ½åˆ†ç±»
- **ğŸ” ç”¨æˆ·ç³»ç»Ÿ** - äºŒç»´ç ç™»å½•ï¼ŒVIPçŠ¶æ€æ£€æµ‹ï¼ŒCookieè‡ªåŠ¨ç®¡ç†

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### å‰ç«¯æŠ€æœ¯æ ˆ
```
Vue 3 (Composition API) + Vite + Pinia + Vue Router
â”œâ”€â”€ å“åº”å¼çŠ¶æ€ç®¡ç† (Pinia)
â”œâ”€â”€ ç»„ä»¶åŒ–å¼€å‘ (Vue 3 Composition API)
â”œâ”€â”€ è·¯ç”±ç®¡ç† (Vue Router)
â”œâ”€â”€ æ„å»ºå·¥å…· (Vite)
â””â”€â”€ UIæ¡†æ¶ (è‡ªç ”ç»„ä»¶åº“)
```

### åç«¯æŠ€æœ¯æ ˆ
```
Node.js + Express + Axios
â”œâ”€â”€ RESTful APIè®¾è®¡
â”œâ”€â”€ ç½‘æ˜“äº‘éŸ³ä¹APIé€†å‘
â”œâ”€â”€ åŠ å¯†ç®—æ³•å®ç°
â”œâ”€â”€ æ–‡ä»¶æµå¤„ç†
â””â”€â”€ Cookieä¼šè¯ç®¡ç†
```

### æ¡Œé¢ç«¯æŠ€æœ¯
```
Electron + Electron Builder
â”œâ”€â”€ è·¨å¹³å°æ¡Œé¢åº”ç”¨
â”œâ”€â”€ åŸç”Ÿç³»ç»Ÿé›†æˆ
â”œâ”€â”€ è‡ªåŠ¨æ›´æ–°æœºåˆ¶
â””â”€â”€ å®‰è£…åŒ…ç”Ÿæˆ
```

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. ç½‘æ˜“äº‘éŸ³ä¹APIé€†å‘å·¥ç¨‹

**æŠ€æœ¯æŒ‘æˆ˜**: ç½‘æ˜“äº‘éŸ³ä¹çš„APIæ¥å£é‡‡ç”¨äº†å¤æ‚çš„åŠ å¯†æœºåˆ¶å’Œåçˆ¬è™«ç­–ç•¥

**å®ç°æŠ€æœ¯æ ˆ**:
- **æŠ“åŒ…åˆ†æ**: ä½¿ç”¨Chrome DevToolsã€Fiddleråˆ†æç½‘ç»œè¯·æ±‚
- **åŠ å¯†ç®—æ³•**: XORåŠ å¯† + MD5å“ˆå¸Œ + Base64ç¼–ç 
- **è¯·æ±‚ä¼ªé€ **: User-Agentã€Refererã€Cookieç­‰è¯·æ±‚å¤´æ¨¡æ‹Ÿ
- **Node.jsä»£ç†**: Expressæ¡†æ¶æ­å»ºAPIä»£ç†æœåŠ¡

**æ ¸å¿ƒå®ç°**:
```javascript
// å°é¢å›¾ç‰‡URLåŠ å¯†ç®—æ³•ï¼ˆä»Pythonç§»æ¤åˆ°JavaScriptï¼‰
function neteaseEncryptId(idStr) {
  const crypto = require('crypto');
  const magic = '3go8&$8*3*3h0k(2)2';
  const songId = idStr.split('');

  // XORåŠ å¯†
  for (let i = 0; i < songId.length; i++) {
    songId[i] = String.fromCharCode(
      songId[i].charCodeAt(0) ^ magic.charCodeAt(i % magic.length)
    );
  }

  // MD5å“ˆå¸Œ + Base64ç¼–ç 
  const m = songId.join('');
  const md5Hash = crypto.createHash('md5').update(m, 'utf8').digest();
  const result = Buffer.from(md5Hash).toString('base64')
    .replace(/\//g, '_')
    .replace(/\+/g, '-');

  return result;
}

// APIè¯·æ±‚å°è£…
class NeteaseAPI {
  constructor() {
    this.baseURL = 'https://music.163.com/api';
    this.headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Referer': 'https://music.163.com/',
      'Accept': 'application/json, text/plain, */*'
    };
  }

  // æœç´¢éŸ³ä¹
  async searchMusic(keywords, limit = 30) {
    const response = await axios.get(`${this.baseURL}/search/get/web`, {
      params: { s: keywords, type: 1, limit },
      headers: this.headers
    });
    return this.processSearchResults(response.data);
  }

  // è·å–æ’­æ”¾é“¾æ¥ï¼ˆæ”¯æŒVIPï¼‰
  async getSongUrl(id, quality = 'exhigh', cookies = {}) {
    const qualityMap = {
      'standard': 128000,
      'exhigh': 320000,
      'lossless': 999000,
      'hires': 999000
    };

    const headers = { ...this.headers };
    if (Object.keys(cookies).length > 0) {
      headers['Cookie'] = Object.entries(cookies)
        .map(([k, v]) => `${k}=${v}`)
        .join('; ');
    }

    const response = await axios.get(`${this.baseURL}/song/enhance/player/url`, {
      params: { ids: `[${id}]`, br: qualityMap[quality] },
      headers
    });

    return response.data;
  }
}
```

### 2. VIPæ­Œæ›²è§£é”æœºåˆ¶

**æŠ€æœ¯æ ˆ**:
- **äºŒç»´ç ç”Ÿæˆ**: ç½‘æ˜“äº‘å®˜æ–¹ç™»å½•API
- **çŠ¶æ€è½®è¯¢**: å®šæ—¶å™¨ + Promiseå¼‚æ­¥å¤„ç†
- **Cookieç®¡ç†**: Node.js fsæ¨¡å— + æ–‡ä»¶æŒä¹…åŒ–
- **æƒé™éªŒè¯**: ç”¨æˆ·è´¦æˆ·API + VIPç­‰çº§åˆ¤æ–­

**æ ¸å¿ƒå®ç°**:
```javascript
// äºŒç»´ç ç™»å½•ç³»ç»Ÿ
class QRLoginSystem {
  constructor() {
    this.checkInterval = null;
    this.maxRetries = 60; // æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ˆ2åˆ†é’Ÿï¼‰
  }

  // ç”Ÿæˆç™»å½•äºŒç»´ç 
  async generateQR() {
    try {
      // 1. è·å–äºŒç»´ç key
      const keyResponse = await axios.get('https://music.163.com/api/login/qrcode/unikey', {
        params: { type: 1 },
        headers: this.getHeaders()
      });

      const unikey = keyResponse.data.unikey;

      // 2. ç”ŸæˆäºŒç»´ç å›¾ç‰‡URL
      const qrImageUrl = `https://music.163.com/api/login/qrcode/create?key=${unikey}&qrimg=true`;

      return {
        unikey,
        qrImageUrl,
        loginUrl: `https://music.163.com/login?codekey=${unikey}`
      };
    } catch (error) {
      throw new Error('äºŒç»´ç ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
  }

  // æ£€æŸ¥ç™»å½•çŠ¶æ€
  async checkLoginStatus(unikey) {
    const response = await axios.get('https://music.163.com/api/login/qrcode/client/login', {
      params: { key: unikey, type: 1 },
      headers: this.getHeaders()
    });

    const { code, message } = response.data;
    const setCookieHeader = response.headers['set-cookie'];

    switch (code) {
      case 801: return { status: 'waiting', message: 'ç­‰å¾…æ‰«ç ' };
      case 802: return { status: 'scanned', message: 'å·²æ‰«ç ï¼Œè¯·ç¡®è®¤' };
      case 803:
        // ç™»å½•æˆåŠŸï¼Œæå–Cookie
        const musicU = this.extractMusicU(setCookieHeader);
        if (musicU) {
          await this.saveCookie(musicU);
          return { status: 'success', message: 'ç™»å½•æˆåŠŸ', cookie: musicU };
        }
        return { status: 'error', message: 'è·å–Cookieå¤±è´¥' };
      case 800: return { status: 'expired', message: 'äºŒç»´ç å·²è¿‡æœŸ' };
      default: return { status: 'error', message: message || 'ç™»å½•å¤±è´¥' };
    }
  }

  // æå–MUSIC_U Cookie
  extractMusicU(setCookieHeader) {
    if (!setCookieHeader) return null;

    for (const cookie of setCookieHeader) {
      if (cookie.includes('MUSIC_U=')) {
        return cookie.split('MUSIC_U=')[1].split(';')[0];
      }
    }
    return null;
  }

  // ä¿å­˜Cookieåˆ°æ–‡ä»¶
  async saveCookie(musicU) {
    const cookieString = `MUSIC_U=${musicU};os=pc;appver=8.9.70;`;
    const cookieFile = path.join(__dirname, 'cookie.txt');
    fs.writeFileSync(cookieFile, cookieString, 'utf8');
  }
}

// VIPçŠ¶æ€æ£€æµ‹
class VIPStatusChecker {
  async checkVIPStatus(cookies) {
    try {
      const headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://music.163.com/'
      };

      // æ·»åŠ Cookieåˆ°è¯·æ±‚å¤´
      if (cookies && Object.keys(cookies).length > 0) {
        headers['Cookie'] = Object.entries(cookies)
          .filter(([k, v]) => k && v)
          .map(([k, v]) => `${k}=${v}`)
          .join('; ');
      }

      const response = await axios.get('https://music.163.com/api/nuser/account/get', {
        headers
      });

      const account = response.data?.account;
      if (account) {
        const vipType = account.vipType || 0;
        return {
          isLogin: true,
          vipType,
          isVip: vipType > 0,
          isBlackVip: vipType >= 10,    // é»‘èƒ¶VIP
          isSuperVip: vipType >= 11,    // é»‘èƒ¶SVIP
          nickname: account.userName || 'æœªçŸ¥ç”¨æˆ·',
          userId: account.id
        };
      }
    } catch (error) {
      console.warn('VIPçŠ¶æ€æ£€æµ‹å¤±è´¥:', error.message);
    }

    return {
      isLogin: false,
      vipType: 0,
      isVip: false,
      isBlackVip: false,
      isSuperVip: false,
      nickname: 'æ¸¸å®¢'
    };
  }
}
```

### 3. ä¸“ä¸šéŸ³é¢‘æ’­æ”¾å¼•æ“

**æŠ€æœ¯æ ˆ**:
- **Web Audio API**: åŸç”ŸéŸ³é¢‘å¤„ç†å’Œè§£ç 
- **AudioContext**: éŸ³é¢‘ä¸Šä¸‹æ–‡ç®¡ç†å’ŒéŸ³æ•ˆå¤„ç†
- **AudioBuffer**: éŸ³é¢‘ç¼“å†²åŒºç®¡ç†å’Œå†…å­˜ä¼˜åŒ–
- **AnalyserNode**: å®æ—¶éŸ³é¢‘åˆ†æå’Œå¯è§†åŒ–

**æ ¸å¿ƒå®ç°**:
```javascript
// ä¸“ä¸šéŸ³é¢‘å¼•æ“
class AudioEngine {
  constructor() {
    this.audioContext = null;
    this.gainNode = null;
    this.analyser = null;
    this.currentSource = null;
    this.audioBuffer = null;
    this.isPlaying = false;
    this.startTime = 0;
    this.pauseTime = 0;

    this.initAudioContext();
  }

  // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
  initAudioContext() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // åˆ›å»ºéŸ³é¢‘èŠ‚ç‚¹å›¾
      this.gainNode = this.audioContext.createGain();
      this.analyser = this.audioContext.createAnalyser();

      // é…ç½®åˆ†æå™¨
      this.analyser.fftSize = 2048;
      this.analyser.smoothingTimeConstant = 0.8;

      // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
      this.gainNode.connect(this.analyser);
      this.analyser.connect(this.audioContext.destination);

    } catch (error) {
      console.error('éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }

  // åŠ è½½éŸ³é¢‘æ–‡ä»¶
  async loadAudio(audioData) {
    try {
      // å¦‚æœæ˜¯æ–‡ä»¶å¯¹è±¡ï¼Œè½¬æ¢ä¸ºArrayBuffer
      let arrayBuffer;
      if (audioData instanceof File || audioData instanceof Blob) {
        arrayBuffer = await audioData.arrayBuffer();
      } else if (audioData instanceof ArrayBuffer) {
        arrayBuffer = audioData;
      } else {
        throw new Error('ä¸æ”¯æŒçš„éŸ³é¢‘æ•°æ®æ ¼å¼');
      }

      // è§£ç éŸ³é¢‘æ•°æ®
      this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

      return {
        duration: this.audioBuffer.duration,
        sampleRate: this.audioBuffer.sampleRate,
        numberOfChannels: this.audioBuffer.numberOfChannels,
        length: this.audioBuffer.length
      };

    } catch (error) {
      console.error('éŸ³é¢‘åŠ è½½å¤±è´¥:', error);
      throw new Error('éŸ³é¢‘æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒæˆ–æ–‡ä»¶æŸå');
    }
  }

  // æ’­æ”¾éŸ³é¢‘
  play(startOffset = 0) {
    if (!this.audioBuffer) {
      throw new Error('æ²¡æœ‰åŠ è½½éŸ³é¢‘æ–‡ä»¶');
    }

    // åœæ­¢å½“å‰æ’­æ”¾
    this.stop();

    // åˆ›å»ºæ–°çš„éŸ³é¢‘æº
    this.currentSource = this.audioContext.createBufferSource();
    this.currentSource.buffer = this.audioBuffer;

    // è¿æ¥åˆ°éŸ³é¢‘èŠ‚ç‚¹å›¾
    this.currentSource.connect(this.gainNode);

    // è®¾ç½®æ’­æ”¾ç»“æŸå›è°ƒ
    this.currentSource.onended = () => {
      this.isPlaying = false;
      this.onPlaybackEnd && this.onPlaybackEnd();
    };

    // å¼€å§‹æ’­æ”¾
    this.currentSource.start(0, startOffset);
    this.startTime = this.audioContext.currentTime - startOffset;
    this.isPlaying = true;

    // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¤„ç†æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾ç­–ç•¥ï¼‰
    if (this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }
  }

  // æš‚åœæ’­æ”¾
  pause() {
    if (this.isPlaying && this.currentSource) {
      this.pauseTime = this.getCurrentTime();
      this.stop();
    }
  }

  // æ¢å¤æ’­æ”¾
  resume() {
    if (this.pauseTime > 0) {
      this.play(this.pauseTime);
      this.pauseTime = 0;
    }
  }

  // åœæ­¢æ’­æ”¾
  stop() {
    if (this.currentSource) {
      try {
        this.currentSource.stop();
      } catch (error) {
        // å¿½ç•¥é‡å¤åœæ­¢çš„é”™è¯¯
      }
      this.currentSource = null;
    }
    this.isPlaying = false;
  }

  // è·å–å½“å‰æ’­æ”¾æ—¶é—´
  getCurrentTime() {
    if (!this.isPlaying || !this.audioBuffer) return this.pauseTime;

    const currentTime = this.audioContext.currentTime - this.startTime;
    return Math.min(currentTime, this.audioBuffer.duration);
  }

  // è®¾ç½®éŸ³é‡
  setVolume(volume) {
    if (this.gainNode) {
      // ä½¿ç”¨æŒ‡æ•°æ›²çº¿å®ç°æ›´è‡ªç„¶çš„éŸ³é‡å˜åŒ–
      this.gainNode.gain.setValueAtTime(volume * volume, this.audioContext.currentTime);
    }
  }

  // è·å–éŸ³é¢‘é¢‘è°±æ•°æ®ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰
  getFrequencyData() {
    if (!this.analyser) return null;

    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);

    return dataArray;
  }

  // è·å–éŸ³é¢‘æ³¢å½¢æ•°æ®
  getWaveformData() {
    if (!this.analyser) return null;

    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteTimeDomainData(dataArray);

    return dataArray;
  }

  // éŸ³é¢‘æ·¡å…¥æ•ˆæœ
  fadeIn(duration = 1.0) {
    if (this.gainNode) {
      const currentTime = this.audioContext.currentTime;
      this.gainNode.gain.setValueAtTime(0, currentTime);
      this.gainNode.gain.linearRampToValueAtTime(1, currentTime + duration);
    }
  }

  // éŸ³é¢‘æ·¡å‡ºæ•ˆæœ
  fadeOut(duration = 1.0) {
    if (this.gainNode) {
      const currentTime = this.audioContext.currentTime;
      this.gainNode.gain.setValueAtTime(1, currentTime);
      this.gainNode.gain.linearRampToValueAtTime(0, currentTime + duration);

      // æ·¡å‡ºå®Œæˆååœæ­¢æ’­æ”¾
      setTimeout(() => this.stop(), duration * 1000);
    }
  }

  // é‡Šæ”¾èµ„æº
  destroy() {
    this.stop();
    if (this.audioContext && this.audioContext.state !== 'closed') {
      this.audioContext.close();
    }
  }
}
```

### 4. æ­Œè¯åŒæ­¥ç³»ç»Ÿ

**æŠ€æœ¯æ ˆ**:
- **LRCè§£æ**: æ­£åˆ™è¡¨è¾¾å¼ + æ—¶é—´æˆ³è§£æ
- **åŒæ­¥ç®—æ³•**: äºŒåˆ†æŸ¥æ‰¾ + requestAnimationFrame
- **DOMä¼˜åŒ–**: è™šæ‹Ÿæ»šåŠ¨ + èŠ‚æµé˜²æŠ–
- **åŠ¨ç”»æ•ˆæœ**: CSS3 Transform + Transition

```javascript
// æ­Œè¯åŒæ­¥å¼•æ“
class LyricSyncEngine {
  constructor() {
    this.lyrics = [];
    this.currentIndex = -1;
    this.animationId = null;
    this.isScrolling = false;
    this.container = null;

    // æ€§èƒ½ä¼˜åŒ–é…ç½®
    this.updateThrottle = 16; // 60fps
    this.lastUpdateTime = 0;
  }

  // LRCæ ¼å¼è§£æ
  parseLRC(lrcContent) {
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    const lines = lrcContent.split('\n');

    lines.forEach(line => {
      const matches = [...line.matchAll(timeRegex)];
      if (matches.length > 0) {
        const text = line.replace(timeRegex, '').trim();

        matches.forEach(match => {
          const minutes = parseInt(match[1]);
          const seconds = parseInt(match[2]);
          const milliseconds = parseInt(match[3].padEnd(3, '0'));

          const timeMs = minutes * 60 * 1000 + seconds * 1000 + milliseconds;

          lyrics.push({
            time: timeMs,
            text: text || 'â™ª',
            minutes,
            seconds,
            milliseconds
          });
        });
      }
    });

    // æŒ‰æ—¶é—´æ’åº
    return lyrics.sort((a, b) => a.time - b.time);
  }

  // åŠ è½½æ­Œè¯
  loadLyrics(lrcContent) {
    this.lyrics = this.parseLRC(lrcContent);
    this.currentIndex = -1;
    this.renderLyrics();
  }

  // æ ¹æ®æ’­æ”¾æ—¶é—´è·å–å½“å‰æ­Œè¯ï¼ˆäºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–ï¼‰
  getCurrentLyricIndex(currentTimeMs) {
    if (this.lyrics.length === 0) return -1;

    let left = 0;
    let right = this.lyrics.length - 1;
    let result = -1;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);

      if (this.lyrics[mid].time <= currentTimeMs) {
        result = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return result;
  }

  // æ›´æ–°æ­Œè¯æ˜¾ç¤ºï¼ˆé«˜æ€§èƒ½å®ç°ï¼‰
  updateLyrics(currentTimeMs) {
    const now = performance.now();

    // èŠ‚æµä¼˜åŒ–ï¼šé™åˆ¶æ›´æ–°é¢‘ç‡
    if (now - this.lastUpdateTime < this.updateThrottle) {
      return;
    }
    this.lastUpdateTime = now;

    const newIndex = this.getCurrentLyricIndex(currentTimeMs);

    if (newIndex !== this.currentIndex) {
      this.currentIndex = newIndex;
      this.highlightCurrentLyric();
      this.scrollToCurrentLyric();
    }
  }

  // æ¸²æŸ“æ­Œè¯åˆ—è¡¨
  renderLyrics() {
    if (!this.container) return;

    const fragment = document.createDocumentFragment();

    this.lyrics.forEach((lyric, index) => {
      const lyricElement = document.createElement('div');
      lyricElement.className = 'lyric-line';
      lyricElement.textContent = lyric.text;
      lyricElement.dataset.index = index;
      lyricElement.dataset.time = lyric.time;

      // æ·»åŠ ç‚¹å‡»è·³è½¬åŠŸèƒ½
      lyricElement.addEventListener('click', () => {
        this.onLyricClick && this.onLyricClick(lyric.time / 1000);
      });

      fragment.appendChild(lyricElement);
    });

    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }

  // é«˜äº®å½“å‰æ­Œè¯
  highlightCurrentLyric() {
    if (!this.container) return;

    // ç§»é™¤ä¹‹å‰çš„é«˜äº®
    const prevActive = this.container.querySelector('.lyric-active');
    if (prevActive) {
      prevActive.classList.remove('lyric-active');
    }

    // æ·»åŠ å½“å‰é«˜äº®
    if (this.currentIndex >= 0) {
      const currentElement = this.container.children[this.currentIndex];
      if (currentElement) {
        currentElement.classList.add('lyric-active');
      }
    }
  }

  // æ»šåŠ¨åˆ°å½“å‰æ­Œè¯ï¼ˆæµç•…åŠ¨ç”»ï¼‰
  scrollToCurrentLyric() {
    if (!this.container || this.currentIndex < 0 || this.isScrolling) return;

    const currentElement = this.container.children[this.currentIndex];
    if (!currentElement) return;

    const containerHeight = this.container.clientHeight;
    const elementTop = currentElement.offsetTop;
    const elementHeight = currentElement.clientHeight;

    // è®¡ç®—æ»šåŠ¨ä½ç½®ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰
    const scrollTop = elementTop - (containerHeight / 2) + (elementHeight / 2);

    // ä½¿ç”¨requestAnimationFrameå®ç°æµç•…æ»šåŠ¨
    this.smoothScrollTo(scrollTop);
  }

  // å¹³æ»‘æ»šåŠ¨å®ç°
  smoothScrollTo(targetScrollTop) {
    const startScrollTop = this.container.scrollTop;
    const distance = targetScrollTop - startScrollTop;
    const duration = 300; // åŠ¨ç”»æ—¶é•¿
    let startTime = null;

    this.isScrolling = true;

    const animateScroll = (currentTime) => {
      if (!startTime) startTime = currentTime;

      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // ä½¿ç”¨easeOutCubicç¼“åŠ¨å‡½æ•°
      const easeProgress = 1 - Math.pow(1 - progress, 3);

      this.container.scrollTop = startScrollTop + distance * easeProgress;

      if (progress < 1) {
        this.animationId = requestAnimationFrame(animateScroll);
      } else {
        this.isScrolling = false;
        this.animationId = null;
      }
    };

    this.animationId = requestAnimationFrame(animateScroll);
  }

  // è®¾ç½®å®¹å™¨å…ƒç´ 
  setContainer(containerElement) {
    this.container = containerElement;
  }

  // é”€æ¯å®ä¾‹
  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    this.lyrics = [];
    this.currentIndex = -1;
    this.container = null;
  }
}
```

### 5. æœ¬åœ°å­˜å‚¨ç³»ç»Ÿ

**æŠ€æœ¯æ ˆ**:
- **IndexedDB**: æµè§ˆå™¨åŸç”Ÿå¤§å®¹é‡å­˜å‚¨
- **Blob API**: äºŒè¿›åˆ¶æ–‡ä»¶å­˜å‚¨å’Œå¤„ç†
- **Web Workers**: åå°æ•°æ®å¤„ç†é¿å…UIé˜»å¡
- **LRU Cache**: æœ€è¿‘æœ€å°‘ä½¿ç”¨ç¼“å­˜ç®—æ³•

```javascript
// æœ¬åœ°å­˜å‚¨ç®¡ç†ç³»ç»Ÿ
class MusicStorageManager {
  constructor() {
    this.dbName = 'MusicPlayerDB';
    this.version = 2;
    this.db = null;
    this.cache = new LRUCache(100); // ç¼“å­˜100é¦–æ­Œæ›²

    this.initDatabase();
  }

  // åˆå§‹åŒ–IndexedDBæ•°æ®åº“
  async initDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        // åˆ›å»ºæ­Œæ›²å­˜å‚¨è¡¨
        if (!db.objectStoreNames.contains('songs')) {
          const songStore = db.createObjectStore('songs', { keyPath: 'id' });
          songStore.createIndex('title', 'title', { unique: false });
          songStore.createIndex('artist', 'artist', { unique: false });
          songStore.createIndex('album', 'album', { unique: false });
          songStore.createIndex('addTime', 'addTime', { unique: false });
          songStore.createIndex('playCount', 'playCount', { unique: false });
        }

        // åˆ›å»ºæ’­æ”¾åˆ—è¡¨å­˜å‚¨è¡¨
        if (!db.objectStoreNames.contains('playlists')) {
          const playlistStore = db.createObjectStore('playlists', { keyPath: 'id' });
          playlistStore.createIndex('name', 'name', { unique: false });
          playlistStore.createIndex('createTime', 'createTime', { unique: false });
        }

        // åˆ›å»ºæ’­æ”¾å†å²è¡¨
        if (!db.objectStoreNames.contains('playHistory')) {
          const historyStore = db.createObjectStore('playHistory', { keyPath: 'id', autoIncrement: true });
          historyStore.createIndex('songId', 'songId', { unique: false });
          historyStore.createIndex('playTime', 'playTime', { unique: false });
        }
      };
    });
  }

  // å­˜å‚¨éŸ³é¢‘æ–‡ä»¶
  async saveSong(songData) {
    try {
      const transaction = this.db.transaction(['songs'], 'readwrite');
      const store = transaction.objectStore('songs');

      // ç”Ÿæˆå”¯ä¸€ID
      const songId = this.generateSongId(songData);

      const songRecord = {
        id: songId,
        title: songData.title || 'æœªçŸ¥æ ‡é¢˜',
        artist: songData.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
        album: songData.album || 'æœªçŸ¥ä¸“è¾‘',
        duration: songData.duration || 0,
        size: songData.size || 0,
        format: songData.format || 'mp3',
        bitrate: songData.bitrate || 128,
        audioBlob: songData.audioBlob,
        coverBlob: songData.coverBlob || null,
        lrcContent: songData.lrcContent || '',
        addTime: Date.now(),
        playCount: 0,
        isFavorite: false,
        tags: songData.tags || []
      };

      await this.promisifyRequest(store.put(songRecord));

      // æ›´æ–°ç¼“å­˜
      this.cache.set(songId, songRecord);

      return songId;
    } catch (error) {
      console.error('ä¿å­˜æ­Œæ›²å¤±è´¥:', error);
      throw error;
    }
  }

  // æ‰¹é‡å¯¼å…¥æœ¬åœ°éŸ³ä¹
  async importLocalMusic(files, onProgress) {
    const results = [];
    const total = files.length;

    // ä½¿ç”¨Web Workerå¤„ç†å¤§é‡æ–‡ä»¶
    const worker = new Worker('/workers/music-import-worker.js');

    return new Promise((resolve, reject) => {
      worker.postMessage({ files: Array.from(files) });

      worker.onmessage = async (event) => {
        const { type, data, progress } = event.data;

        switch (type) {
          case 'progress':
            onProgress && onProgress(progress);
            break;

          case 'fileProcessed':
            try {
              const songId = await this.saveSong(data);
              results.push({ songId, metadata: data });
            } catch (error) {
              console.error('ä¿å­˜æ­Œæ›²å¤±è´¥:', error);
            }
            break;

          case 'complete':
            worker.terminate();
            resolve(results);
            break;

          case 'error':
            worker.terminate();
            reject(new Error(data.message));
            break;
        }
      };

      worker.onerror = (error) => {
        worker.terminate();
        reject(error);
      };
    });
  }

  // è·å–æ­Œæ›²æ•°æ®
  async getSong(songId) {
    // å…ˆä»ç¼“å­˜è·å–
    if (this.cache.has(songId)) {
      return this.cache.get(songId);
    }

    try {
      const transaction = this.db.transaction(['songs'], 'readonly');
      const store = transaction.objectStore('songs');
      const song = await this.promisifyRequest(store.get(songId));

      if (song) {
        this.cache.set(songId, song);
      }

      return song;
    } catch (error) {
      console.error('è·å–æ­Œæ›²å¤±è´¥:', error);
      return null;
    }
  }

  // æœç´¢æ­Œæ›²
  async searchSongs(query, options = {}) {
    const { limit = 50, offset = 0, sortBy = 'addTime', sortOrder = 'desc' } = options;

    try {
      const transaction = this.db.transaction(['songs'], 'readonly');
      const store = transaction.objectStore('songs');

      let results = [];

      if (query) {
        // æ¨¡ç³Šæœç´¢å®ç°
        const allSongs = await this.promisifyRequest(store.getAll());
        const queryLower = query.toLowerCase();

        results = allSongs.filter(song =>
          song.title.toLowerCase().includes(queryLower) ||
          song.artist.toLowerCase().includes(queryLower) ||
          song.album.toLowerCase().includes(queryLower)
        );
      } else {
        // è·å–æ‰€æœ‰æ­Œæ›²
        results = await this.promisifyRequest(store.getAll());
      }

      // æ’åº
      results.sort((a, b) => {
        const aVal = a[sortBy];
        const bVal = b[sortBy];

        if (sortOrder === 'desc') {
          return bVal > aVal ? 1 : -1;
        } else {
          return aVal > bVal ? 1 : -1;
        }
      });

      // åˆ†é¡µ
      return results.slice(offset, offset + limit);

    } catch (error) {
      console.error('æœç´¢æ­Œæ›²å¤±è´¥:', error);
      return [];
    }
  }

  // åˆ é™¤æ­Œæ›²
  async deleteSong(songId) {
    try {
      const transaction = this.db.transaction(['songs'], 'readwrite');
      const store = transaction.objectStore('songs');

      await this.promisifyRequest(store.delete(songId));

      // ä»ç¼“å­˜ä¸­ç§»é™¤
      this.cache.delete(songId);

      return true;
    } catch (error) {
      console.error('åˆ é™¤æ­Œæ›²å¤±è´¥:', error);
      return false;
    }
  }

  // æ›´æ–°æ’­æ”¾æ¬¡æ•°
  async updatePlayCount(songId) {
    try {
      const song = await this.getSong(songId);
      if (song) {
        song.playCount = (song.playCount || 0) + 1;
        song.lastPlayTime = Date.now();

        const transaction = this.db.transaction(['songs'], 'readwrite');
        const store = transaction.objectStore('songs');
        await this.promisifyRequest(store.put(song));

        // æ›´æ–°ç¼“å­˜
        this.cache.set(songId, song);

        // è®°å½•æ’­æ”¾å†å²
        await this.addPlayHistory(songId);
      }
    } catch (error) {
      console.error('æ›´æ–°æ’­æ”¾æ¬¡æ•°å¤±è´¥:', error);
    }
  }

  // æ·»åŠ æ’­æ”¾å†å²
  async addPlayHistory(songId) {
    try {
      const transaction = this.db.transaction(['playHistory'], 'readwrite');
      const store = transaction.objectStore('playHistory');

      const historyRecord = {
        songId,
        playTime: Date.now()
      };

      await this.promisifyRequest(store.add(historyRecord));

      // æ¸…ç†æ—§çš„æ’­æ”¾å†å²ï¼ˆä¿ç•™æœ€è¿‘1000æ¡ï¼‰
      await this.cleanupPlayHistory();

    } catch (error) {
      console.error('æ·»åŠ æ’­æ”¾å†å²å¤±è´¥:', error);
    }
  }

  // æ¸…ç†æ’­æ”¾å†å²
  async cleanupPlayHistory() {
    try {
      const transaction = this.db.transaction(['playHistory'], 'readwrite');
      const store = transaction.objectStore('playHistory');
      const index = store.index('playTime');

      const allHistory = await this.promisifyRequest(index.getAll());

      if (allHistory.length > 1000) {
        // æŒ‰æ—¶é—´æ’åºï¼Œåˆ é™¤æœ€æ—§çš„è®°å½•
        allHistory.sort((a, b) => b.playTime - a.playTime);
        const toDelete = allHistory.slice(1000);

        for (const record of toDelete) {
          await this.promisifyRequest(store.delete(record.id));
        }
      }
    } catch (error) {
      console.error('æ¸…ç†æ’­æ”¾å†å²å¤±è´¥:', error);
    }
  }

  // ç”Ÿæˆæ­Œæ›²ID
  generateSongId(songData) {
    const crypto = window.crypto || window.msCrypto;
    const array = new Uint32Array(1);
    crypto.getRandomValues(array);

    const timestamp = Date.now();
    const random = array[0];
    const title = songData.title || '';
    const artist = songData.artist || '';

    return `${timestamp}_${random}_${btoa(title + artist).replace(/[^a-zA-Z0-9]/g, '').substring(0, 10)}`;
  }

  // PromiseåŒ–IndexedDBè¯·æ±‚
  promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

// LRUç¼“å­˜å®ç°
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      // ç§»åˆ°æœ€å‰é¢
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // åˆ é™¤æœ€æ—§çš„é¡¹
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  has(key) {
    return this.cache.has(key);
  }

  delete(key) {
    return this.cache.delete(key);
  }
}
```

### 6. å…ƒæ•°æ®æå–ç³»ç»Ÿ

**æŠ€æœ¯æ ˆ**:
- **File API**: æµè§ˆå™¨æ–‡ä»¶è¯»å–å’Œå¤„ç†
- **ArrayBuffer**: äºŒè¿›åˆ¶æ•°æ®å¤„ç†
- **ID3 Parser**: éŸ³é¢‘å…ƒæ•°æ®è§£æ
- **Canvas API**: å°é¢å›¾ç‰‡å¤„ç†å’Œå‹ç¼©

**æ ¸å¿ƒå®ç°**:
```javascript
// éŸ³é¢‘å…ƒæ•°æ®æå–å™¨
class AudioMetadataExtractor {
  constructor() {
    this.supportedFormats = ['mp3', 'flac', 'wav', 'ogg', 'm4a', 'aac'];
  }

  // æå–éŸ³é¢‘æ–‡ä»¶å…ƒæ•°æ®
  async extractMetadata(file) {
    try {
      const fileExtension = this.getFileExtension(file.name);

      if (!this.supportedFormats.includes(fileExtension)) {
        throw new Error(`ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ${fileExtension}`);
      }

      // åŸºç¡€ä¿¡æ¯
      const basicInfo = {
        fileName: file.name,
        fileSize: file.size,
        format: fileExtension,
        lastModified: file.lastModified
      };

      // æå–éŸ³é¢‘æ—¶é•¿å’ŒæŠ€æœ¯ä¿¡æ¯
      const audioInfo = await this.extractAudioInfo(file);

      // æå–ID3æ ‡ç­¾ä¿¡æ¯
      const id3Info = await this.extractID3Tags(file);

      // æå–å°é¢å›¾ç‰‡
      const coverInfo = await this.extractCoverArt(file);

      return {
        ...basicInfo,
        ...audioInfo,
        ...id3Info,
        ...coverInfo,
        bitrate: this.calculateBitrate(file.size, audioInfo.duration),
        addTime: Date.now()
      };

    } catch (error) {
      console.error('å…ƒæ•°æ®æå–å¤±è´¥:', error);
      return this.getDefaultMetadata(file);
    }
  }

  // æå–éŸ³é¢‘åŸºç¡€ä¿¡æ¯
  async extractAudioInfo(file) {
    return new Promise((resolve) => {
      const audio = new Audio();
      const objectUrl = URL.createObjectURL(file);

      audio.onloadedmetadata = () => {
        const info = {
          duration: audio.duration,
          hasAudio: !isNaN(audio.duration) && audio.duration > 0
        };

        URL.revokeObjectURL(objectUrl);
        resolve(info);
      };

      audio.onerror = () => {
        URL.revokeObjectURL(objectUrl);
        resolve({ duration: 0, hasAudio: false });
      };

      audio.src = objectUrl;
    });
  }

  // æå–ID3æ ‡ç­¾ä¿¡æ¯
  async extractID3Tags(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const dataView = new DataView(arrayBuffer);

      // æ£€æŸ¥ID3v2æ ‡ç­¾
      if (this.hasID3v2Tag(dataView)) {
        return await this.parseID3v2(dataView);
      }

      // æ£€æŸ¥ID3v1æ ‡ç­¾
      if (this.hasID3v1Tag(dataView)) {
        return this.parseID3v1(dataView);
      }

      // å°è¯•ä»æ–‡ä»¶åè§£æ
      return this.parseFromFileName(file.name);

    } catch (error) {
      console.error('ID3æ ‡ç­¾è§£æå¤±è´¥:', error);
      return this.parseFromFileName(file.name);
    }
  }

  // è§£æID3v2æ ‡ç­¾
  async parseID3v2(dataView) {
    const header = this.parseID3v2Header(dataView);
    if (!header) return {};

    const frames = {};
    let offset = 10; // ID3v2å¤´éƒ¨é•¿åº¦

    while (offset < header.size + 10) {
      const frame = this.parseID3v2Frame(dataView, offset);
      if (!frame) break;

      frames[frame.id] = frame.data;
      offset += frame.size + 10; // å¸§å¤´éƒ¨é•¿åº¦ä¸º10å­—èŠ‚
    }

    return {
      title: frames.TIT2 || frames.TT2 || '',
      artist: frames.TPE1 || frames.TP1 || '',
      album: frames.TALB || frames.TAL || '',
      year: frames.TYER || frames.TYE || '',
      genre: frames.TCON || frames.TCO || '',
      track: frames.TRCK || frames.TRK || '',
      albumArtist: frames.TPE2 || frames.TP2 || '',
      composer: frames.TCOM || frames.TCM || ''
    };
  }

  // è§£æID3v2å¸§
  parseID3v2Frame(dataView, offset) {
    try {
      // è¯»å–å¸§IDï¼ˆ4å­—èŠ‚ï¼‰
      const frameId = String.fromCharCode(
        dataView.getUint8(offset),
        dataView.getUint8(offset + 1),
        dataView.getUint8(offset + 2),
        dataView.getUint8(offset + 3)
      );

      // è¯»å–å¸§å¤§å°ï¼ˆ4å­—èŠ‚ï¼‰
      const frameSize = dataView.getUint32(offset + 4, false);

      // è·³è¿‡æ ‡å¿—ä½ï¼ˆ2å­—èŠ‚ï¼‰
      const dataOffset = offset + 10;

      // è¯»å–å¸§æ•°æ®
      let frameData = '';
      const encoding = dataView.getUint8(dataOffset);

      // æ ¹æ®ç¼–ç æ–¹å¼è§£ææ–‡æœ¬
      if (encoding === 0) {
        // ISO-8859-1
        for (let i = dataOffset + 1; i < dataOffset + frameSize; i++) {
          const byte = dataView.getUint8(i);
          if (byte === 0) break;
          frameData += String.fromCharCode(byte);
        }
      } else if (encoding === 1) {
        // UTF-16
        frameData = this.parseUTF16(dataView, dataOffset + 1, frameSize - 1);
      } else if (encoding === 3) {
        // UTF-8
        frameData = this.parseUTF8(dataView, dataOffset + 1, frameSize - 1);
      }

      return {
        id: frameId,
        size: frameSize,
        data: frameData.trim()
      };

    } catch (error) {
      return null;
    }
  }

  // æå–å°é¢å›¾ç‰‡
  async extractCoverArt(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const dataView = new DataView(arrayBuffer);

      // æŸ¥æ‰¾APICå¸§ï¼ˆå°é¢å›¾ç‰‡ï¼‰
      const apicFrame = this.findAPICFrame(dataView);
      if (apicFrame) {
        const coverBlob = new Blob([apicFrame.imageData], { type: apicFrame.mimeType });

        // å‹ç¼©å°é¢å›¾ç‰‡
        const compressedCover = await this.compressCoverImage(coverBlob);

        return {
          hasCover: true,
          coverBlob: compressedCover,
          coverSize: compressedCover.size,
          coverType: apicFrame.mimeType
        };
      }

      return { hasCover: false, coverBlob: null };

    } catch (error) {
      console.error('å°é¢æå–å¤±è´¥:', error);
      return { hasCover: false, coverBlob: null };
    }
  }

  // å‹ç¼©å°é¢å›¾ç‰‡
  async compressCoverImage(imageBlob, maxSize = 300) {
    return new Promise((resolve) => {
      const img = new Image();
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      img.onload = () => {
        // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
        let { width, height } = img;

        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height);
          width *= ratio;
          height *= ratio;
        }

        // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);

        // è½¬æ¢ä¸ºBlob
        canvas.toBlob((blob) => {
          resolve(blob);
        }, 'image/jpeg', 0.8);
      };

      img.onerror = () => resolve(imageBlob);
      img.src = URL.createObjectURL(imageBlob);
    });
  }

  // ä»æ–‡ä»¶åè§£æä¿¡æ¯
  parseFromFileName(fileName) {
    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, '');

    // å°è¯•è§£æ "è‰ºæœ¯å®¶ - æ­Œæ›²å" æ ¼å¼
    const dashMatch = nameWithoutExt.match(/^(.+?)\s*-\s*(.+)$/);
    if (dashMatch) {
      return {
        artist: dashMatch[1].trim(),
        title: dashMatch[2].trim()
      };
    }

    // å°è¯•è§£æ "æ­Œæ›²å - è‰ºæœ¯å®¶" æ ¼å¼
    const reverseDashMatch = nameWithoutExt.match(/^(.+?)\s*-\s*(.+)$/);
    if (reverseDashMatch) {
      return {
        title: reverseDashMatch[1].trim(),
        artist: reverseDashMatch[2].trim()
      };
    }

    // é»˜è®¤ä½¿ç”¨æ–‡ä»¶åä½œä¸ºæ ‡é¢˜
    return {
      title: nameWithoutExt,
      artist: 'æœªçŸ¥è‰ºæœ¯å®¶'
    };
  }

  // è®¡ç®—æ¯”ç‰¹ç‡
  calculateBitrate(fileSize, duration) {
    if (!duration || duration <= 0) return 0;

    // æ¯”ç‰¹ç‡ = (æ–‡ä»¶å¤§å° * 8) / æ—¶é•¿ / 1000
    return Math.round((fileSize * 8) / duration / 1000);
  }

  // è·å–æ–‡ä»¶æ‰©å±•å
  getFileExtension(fileName) {
    return fileName.split('.').pop().toLowerCase();
  }

  // è·å–é»˜è®¤å…ƒæ•°æ®
  getDefaultMetadata(file) {
    const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');

    return {
      fileName: file.name,
      fileSize: file.size,
      format: this.getFileExtension(file.name),
      title: nameWithoutExt,
      artist: 'æœªçŸ¥è‰ºæœ¯å®¶',
      album: 'æœªçŸ¥ä¸“è¾‘',
      duration: 0,
      bitrate: 0,
      hasCover: false,
      coverBlob: null,
      addTime: Date.now()
    };
  }
}
```

### 7. æœ¬åœ°å­˜å‚¨ç³»ç»Ÿ

**æŠ€æœ¯æ¶æ„**:
- **IndexedDBå­˜å‚¨**: é‡‡ç”¨æµè§ˆå™¨åŸç”ŸIndexedDBå®ç°å¤§å®¹é‡æœ¬åœ°å­˜å‚¨
- **æ–‡ä»¶ç®¡ç†**: éŸ³é¢‘æ–‡ä»¶ã€å°é¢å›¾ç‰‡ã€æ­Œè¯æ–‡ä»¶çš„ç»Ÿä¸€ç®¡ç†
- **æ•°æ®ç»“æ„**: è®¾è®¡äº†é«˜æ•ˆçš„éŸ³ä¹åº“æ•°æ®æ¨¡å‹ï¼Œæ”¯æŒå¿«é€Ÿæ£€ç´¢å’Œåˆ†ç±»
- **å­˜å‚¨ä¼˜åŒ–**: å®ç°äº†å¢é‡æ›´æ–°å’Œåƒåœ¾å›æ”¶æœºåˆ¶

```javascript
// æœ¬åœ°å­˜å‚¨æ ¸å¿ƒå®ç°
class MusicStorage {
  constructor() {
    this.dbName = 'MusicPlayerDB';
    this.version = 1;
    this.db = null;
  }

  // å­˜å‚¨éŸ³é¢‘æ–‡ä»¶
  async saveAudioFile(songId, audioBlob, metadata) {
    const transaction = this.db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');

    const songData = {
      id: songId,
      audio: audioBlob,
      metadata: metadata,
      addTime: Date.now(),
      playCount: 0
    };

    return await store.put(songData);
  }

  // æ‰¹é‡å¯¼å…¥æœ¬åœ°éŸ³ä¹
  async importLocalMusic(files) {
    const results = [];
    for (const file of files) {
      const metadata = await this.extractMetadata(file);
      const songId = this.generateSongId(metadata);
      await this.saveAudioFile(songId, file, metadata);
      results.push({ id: songId, metadata });
    }
    return results;
  }
}
```

### 8. æœ¬åœ°éŸ³ä¹ç®¡ç†

**åŠŸèƒ½ç‰¹æ€§**:
- **æ–‡ä»¶å¯¼å…¥**: æ”¯æŒæ‹–æ‹½å¯¼å…¥ã€æ–‡ä»¶å¤¹æ‰¹é‡å¯¼å…¥æœ¬åœ°éŸ³ä¹
- **å…ƒæ•°æ®æå–**: è‡ªåŠ¨æå–éŸ³é¢‘æ–‡ä»¶çš„æ ‡é¢˜ã€è‰ºæœ¯å®¶ã€ä¸“è¾‘ã€æ—¶é•¿ç­‰ä¿¡æ¯
- **æ™ºèƒ½åˆ†ç±»**: æŒ‰è‰ºæœ¯å®¶ã€ä¸“è¾‘ã€å¹´ä»½ã€æµæ´¾ç­‰ç»´åº¦è‡ªåŠ¨åˆ†ç±»
- **é‡å¤æ£€æµ‹**: æ™ºèƒ½æ£€æµ‹é‡å¤éŸ³ä¹ï¼Œé¿å…é‡å¤å­˜å‚¨

```javascript
// å…ƒæ•°æ®æå–å®ç°
class MetadataExtractor {
  async extractFromFile(file) {
    return new Promise((resolve) => {
      const audio = new Audio();
      audio.onloadedmetadata = () => {
        const metadata = {
          title: this.extractTitle(file.name),
          duration: audio.duration,
          size: file.size,
          format: this.getFileFormat(file.name),
          bitrate: this.estimateBitrate(file.size, audio.duration)
        };
        resolve(metadata);
      };
      audio.src = URL.createObjectURL(file);
    });
  }
}
```

### 9. æ•°æ®æŒä¹…åŒ–ç­–ç•¥

**æŠ€æœ¯å®ç°**:
- **åˆ†å±‚å­˜å‚¨**: éŸ³é¢‘æ–‡ä»¶ã€å›¾ç‰‡ã€æ–‡æœ¬æ•°æ®åˆ†åˆ«å­˜å‚¨ï¼Œä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
- **ç¼“å­˜æœºåˆ¶**: å®ç°äº†LRUç¼“å­˜ç®—æ³•ï¼Œçƒ­é—¨æ­Œæ›²ä¼˜å…ˆä¿ç•™åœ¨å†…å­˜
- **æ•°æ®åŒæ­¥**: æ”¯æŒæ’­æ”¾å†å²ã€æ”¶è—åˆ—è¡¨çš„å®æ—¶åŒæ­¥
- **å¤‡ä»½æ¢å¤**: æ”¯æŒéŸ³ä¹åº“çš„å¯¼å‡ºå’Œå¯¼å…¥åŠŸèƒ½

### 10. ç°ä»£åŒ–UI/UXè®¾è®¡

**è®¾è®¡äº®ç‚¹**:
- **CDåŠ¨ç”»**: å®ç°äº†é€¼çœŸçš„CDæ—‹è½¬åŠ¨ç”»ï¼Œæ’­æ”¾æ—¶æŒç»­æ—‹è½¬
- **è¿›åº¦æ¡**: å¯æ‹–æ‹½çš„è¿›åº¦æ¡ï¼Œæ”¯æŒç²¾ç¡®å®šä½å’Œé¢„è§ˆ
- **å¯è§†åŒ–**: éŸ³é¢‘é¢‘è°±å¯è§†åŒ–ï¼Œå®æ—¶å±•ç¤ºéŸ³é¢‘æ³¢å½¢
- **å“åº”å¼**: é€‚é…ä¸åŒå±å¹•å°ºå¯¸ï¼Œæ”¯æŒçª—å£ç¼©æ”¾
- **ä¸»é¢˜ç³»ç»Ÿ**: æ—¥å¤œæ¨¡å¼åˆ‡æ¢ï¼Œæ”¯æŒè‡ªå®šä¹‰ä¸»é¢˜è‰²å½©
- **å¾®äº¤äº’**: æŒ‰é’®æ‚¬åœæ•ˆæœã€åŠ è½½åŠ¨ç”»ã€çŠ¶æ€åé¦ˆç­‰ç»†èŠ‚ä¼˜åŒ–

## ğŸš€ é¡¹ç›®äº®ç‚¹

### æŠ€æœ¯åˆ›æ–°
1. **APIé€†å‘å·¥ç¨‹** - æ·±åº¦åˆ†æå¹¶å¤ç°äº†ç½‘æ˜“äº‘éŸ³ä¹çš„æ ¸å¿ƒAPIæœºåˆ¶
2. **éŸ³é¢‘å¼•æ“ä¼˜åŒ–** - è‡ªç ”éŸ³é¢‘æ’­æ”¾å¼•æ“ï¼Œæ”¯æŒå¤šæ ¼å¼æ— æŸæ’­æ”¾
3. **æœ¬åœ°å­˜å‚¨æ¶æ„** - åŸºäºIndexedDBçš„å¤§å®¹é‡éŸ³ä¹åº“å­˜å‚¨ç³»ç»Ÿ
4. **å…ƒæ•°æ®æå–** - è‡ªåŠ¨æå–éŸ³é¢‘æ–‡ä»¶å…ƒä¿¡æ¯çš„æ™ºèƒ½åˆ†æç³»ç»Ÿ
5. **åŠ å¯†ç®—æ³•å®ç°** - ä»Pythonç§»æ¤å¹¶ä¼˜åŒ–äº†å›¾ç‰‡URLåŠ å¯†ç®—æ³•
6. **æ­Œè¯åŒæ­¥ç®—æ³•** - å®ç°æ¯«ç§’çº§ç²¾åº¦çš„æ­Œè¯æ—¶é—´åŒæ­¥ç³»ç»Ÿ
7. **æµåª’ä½“å¤„ç†** - é«˜æ•ˆçš„éŸ³é¢‘æµä¸‹è½½ã€ç¼“å­˜å’Œæ’­æ”¾æœºåˆ¶
8. **è·¨å¹³å°æ¶æ„** - ä¸€å¥—ä»£ç æ”¯æŒWindows/macOS/Linuxå¤šå¹³å°

### å·¥ç¨‹å®è·µ
1. **æ¨¡å—åŒ–è®¾è®¡** - å‰åç«¯åˆ†ç¦»ï¼ŒéŸ³é¢‘å¼•æ“ç‹¬ç«‹å°è£…ï¼Œå­˜å‚¨å±‚æŠ½è±¡
2. **æ€§èƒ½ä¼˜åŒ–** - éŸ³é¢‘ç¼“å†²æ± ã€LRUç¼“å­˜ã€æ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ç­‰ä¼˜åŒ–
3. **æ•°æ®ç®¡ç†** - IndexedDBåˆ†å±‚å­˜å‚¨ï¼Œæ”¯æŒTBçº§éŸ³ä¹åº“ç®¡ç†
4. **æ–‡ä»¶å¤„ç†** - æ‰¹é‡å¯¼å…¥ã€é‡å¤æ£€æµ‹ã€å…ƒæ•°æ®æå–ç­‰æ™ºèƒ½åŠŸèƒ½
5. **é”™è¯¯å¤„ç†** - å®Œå–„çš„å¼‚å¸¸æ•è·å’Œæ•°æ®æ¢å¤æœºåˆ¶
6. **æ’­æ”¾ä½“éªŒ** - æ— ç¼åˆ‡æ¢ã€æ–­ç‚¹ç»­æ’­ã€æ’­æ”¾å†å²è®°å½•ç­‰åŠŸèƒ½

### å®‰å…¨è€ƒè™‘
1. **æ•°æ®åŠ å¯†** - ç”¨æˆ·æ•°æ®æœ¬åœ°åŠ å¯†å­˜å‚¨
2. **è¯·æ±‚å®‰å…¨** - APIè¯·æ±‚ç­¾åå’Œé˜²é‡æ”¾æ”»å‡»
3. **éšç§ä¿æŠ¤** - æœ€å°åŒ–æ•°æ®æ”¶é›†ï¼Œç”¨æˆ·éšç§ä¼˜å…ˆ

## ğŸ“Š é¡¹ç›®æ•°æ®

- **ä»£ç é‡**: çº¦18,000è¡Œ (å‰ç«¯9k+ åç«¯4k+ éŸ³é¢‘å¼•æ“3k+ å­˜å‚¨å±‚2k+)
- **ç»„ä»¶æ•°**: 30+ä¸ªå¯å¤ç”¨Vueç»„ä»¶ï¼ŒåŒ…å«ä¸“ä¸šéŸ³é¢‘æ’­æ”¾å’Œå­˜å‚¨ç®¡ç†ç»„ä»¶
- **APIæ¥å£**: 15ä¸ªæ ¸å¿ƒæ¥å£ï¼Œè¦†ç›–æœç´¢ã€ä¸‹è½½ã€æ’­æ”¾ã€å­˜å‚¨ã€ç”¨æˆ·ç®¡ç†
- **éŸ³é¢‘æ ¼å¼**: æ”¯æŒMP3ã€FLACã€APEã€WAVã€OGGç­‰ä¸»æµæ ¼å¼
- **éŸ³è´¨æ”¯æŒ**: 128k-1411kå¤šç§éŸ³è´¨ï¼Œæœ€é«˜æ”¯æŒ24bit/192kHz
- **å­˜å‚¨èƒ½åŠ›**: æ”¯æŒTBçº§éŸ³ä¹åº“ï¼Œå•åº“å¯ç®¡ç†10ä¸‡+é¦–æ­Œæ›²
- **æ’­æ”¾åŠŸèƒ½**: æ”¯æŒ15+ç§æ’­æ”¾æ¨¡å¼å’ŒéŸ³æ•ˆå¤„ç†
- **æ€§èƒ½æŒ‡æ ‡**: 1000é¦–æ­Œæ›²åº“å†…å­˜å ç”¨<100MBï¼Œå¯åŠ¨æ—¶é—´<3ç§’

## ğŸ¯ è§£å†³çš„æ ¸å¿ƒé—®é¢˜

1. **ç‰ˆæƒéŸ³ä¹è·å–éš¾é¢˜** - é€šè¿‡åˆæ³•APIè°ƒç”¨å®ç°éŸ³ä¹èµ„æºè·å–
2. **è·¨å¹³å°å…¼å®¹æ€§** - ä½¿ç”¨Electronå®ç°ä¸€æ¬¡å¼€å‘ï¼Œå¤šå¹³å°è¿è¡Œ
3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–** - ä»UIè®¾è®¡åˆ°äº¤äº’é€»è¾‘çš„å…¨æ–¹ä½ä¼˜åŒ–
4. **æ€§èƒ½ç“¶é¢ˆçªç ´** - å¤§æ–‡ä»¶ä¸‹è½½ã€å†…å­˜ç®¡ç†ã€æ¸²æŸ“ä¼˜åŒ–ç­‰æŠ€æœ¯éš¾ç‚¹

## ğŸ”® æŠ€æœ¯æ”¶è·

é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘æ·±å…¥æŒæ¡äº†ï¼š

- **å…¨æ ˆå¼€å‘èƒ½åŠ›** - ä»å‰ç«¯UIåˆ°åç«¯APIçš„å®Œæ•´å¼€å‘æµç¨‹
- **é€†å‘å·¥ç¨‹æŠ€èƒ½** - APIåˆ†æã€åŠ å¯†ç®—æ³•é€†å‘ã€åçˆ¬è™«å¯¹æŠ—
- **æ€§èƒ½ä¼˜åŒ–ç»éªŒ** - å¤§å‹å‰ç«¯åº”ç”¨çš„æ€§èƒ½è°ƒä¼˜å®è·µ
- **ç”¨æˆ·ä½“éªŒè®¾è®¡** - ä»æŠ€æœ¯å®ç°åˆ°ç”¨æˆ·ä½“éªŒçš„å¹³è¡¡è‰ºæœ¯
- **å·¥ç¨‹åŒ–æ€ç»´** - ä»£ç ç»„ç»‡ã€æ¨¡å—è®¾è®¡ã€éƒ¨ç½²å‘å¸ƒçš„å·¥ç¨‹å®è·µ

## ğŸ“ˆ é¡¹ç›®ä»·å€¼

è¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„éŸ³ä¹æ’­æ”¾å™¨ï¼Œæ›´æ˜¯ç°ä»£WebæŠ€æœ¯æ ˆçš„ç»¼åˆå®è·µï¼š

- å±•ç¤ºäº†å¤æ‚ä¸šåŠ¡é€»è¾‘çš„æŠ€æœ¯å®ç°èƒ½åŠ›
- ä½“ç°äº†å¯¹ç”¨æˆ·ä½“éªŒå’Œäº§å“ç»†èŠ‚çš„æ·±åº¦æ€è€ƒ
- è¯æ˜äº†ç‹¬ç«‹è§£å†³æŠ€æœ¯éš¾é¢˜çš„èƒ½åŠ›
- åæ˜ äº†å¯¹æ–°æŠ€æœ¯çš„å­¦ä¹ å’Œåº”ç”¨èƒ½åŠ›

---

*è¿™ä¸ªé¡¹ç›®è®©æˆ‘æ·±åˆ»ç†è§£äº†ä»0åˆ°1æ„å»ºä¸€ä¸ªå®Œæ•´äº§å“çš„å…¨è¿‡ç¨‹ï¼Œä»æŠ€æœ¯é€‰å‹åˆ°æ¶æ„è®¾è®¡ï¼Œä»åŠŸèƒ½å®ç°åˆ°ç”¨æˆ·ä½“éªŒï¼Œæ¯ä¸€ä¸ªç¯èŠ‚éƒ½æ˜¯å®è´µçš„å­¦ä¹ ç»å†ã€‚*
